# EVM-PUZZLES

EVM Puzzles is created by Franco Victorio... [see link](https://github.com/fvictorio/evm-puzzles), each puzzle includes sending a successful transaction to a contract. The bytecode of the contract is always provided, and we just need to fill the transaction data that won't revert the execution, below I'm just going to try as much as possible to give subtle hints on how to solve each level.

# How to play 
```
git clone https://github.com/fvictorio/evm-puzzles.git
cd evm-puzzles
npm install
npx hardhat play
```

### Level 1

Here we just need make the contract jump to the PC (program counter) 08 that is marked by the JUMPDEST opcode.
You might think, from where do we get the `value` to use for `JUMP`, well remember the EVM stack works as a LIFO (Last In, First Out) queue so that means that the `JUMP` takes in the first value from the stack and uses as the parameter to where it needs to jump to.
And for this level the `value` is added to the stack from the `CALLVALUE` opcode, since this is the forst opcode that's been executed, remember that the `CALLVALUE` opcode pushes the value of our current call in `wei`, so in essence we need to pass in the correct value to the contract in order to make the `CALLVALUE` opcode to push the correct byte offset to make it jump to the valid JUMPDEST at PC 8.

### Level 2

The case here is similar to that of the previous level since we just need to have the correct value in the EVM Stack when the JUMP opcode is executed. You should know we need the value 6 in order to land in a valid JUMPDEST opcode.

Asides `CALLVALUE` which we know to push the `msg.value` to the stack, here we also have `CODESIZE`, what this opcode does is just push the contract's code size in bytes to the stack, and then the `SUB` opcode just as the name it pops 2 values from the stack, substracts them and then push the result back to the stack

NB: After `SUB` the stack would have the value CODESIZE - CALLVALUE. 


### Level 3

This level is still a look alike of the previous two, we just need to have the value `4` in the stack when we jump in order to land in a valid `JUMPDEST` opcode, the only opcode present in this level is the `CALLDATASIZE` which just pushes the byte size of the calldata to the stack.

Below is OZ's explanation of what a calldata is, this should help you understand what to pass in
"the calldata is an encoded chunk of hexadecimal numbers that contains information about what function of the contract we want to call, and it’s arguments or data. Simply put, it consists of a “function id”, which is generated by hashing the function’s signature (truncated to the first leading four bytes) followed by the packed arguments data."



### Level 4

Similar to previous levels we need to pass the correct value to the `CALLVALUE` opcode to make the jump valid that means that it has to be at where the JUMPDEST opcode exists at the PC 10 (0A in hex).

Here we have the `CALLVALUE` and `CODESIZE` opcodes, from previous levels we know what they both do, but in addition for this level we have `XOR` opcode, what this does is pop the top 2 valuse in the stack and then performs the bitwise XOR operation between them and the result is pushed back on stack, don't forget LIFO. In short we need to pass in a `msg.value` after which with the XOR operation must equal 10, note that that our `CODESIZE` is 12.


### Level 5

Here the `JUMPI` opcode is introduced and this opcode can be used to implement functionalities like loops and conditions.

NB: when the `JUMPI` opcode is executed it pops 2 values from the stack, the first being the PC value with the valid JUMPDEST instruction, and the second value is a bool flag (0 or 1) where if 1 we jump if otherwise we don't jump.

So to solve this level all we need to pass is a value whose square is equal to 0100 (the 2 bytes value that's been passed in the stack by the `PUSH2` opcode) you might think why square? well after passing in the value using the `CALLVALUE` opcode, the `DUP1` opcode gets executed and this opocode just duplicates the first value in the stack and push it on top of the stack, then the `MUL` opcode is executed which just multiplies the top two values in the stack, then the `PUSH2` is called that passes the 0100 and then the `EQ` opcode which just pops 2 values from the stack, and returns 1 to the stack if the 2 values are equal otherwise 0, since the last opcode before the `JUMP` is to `PUSH` a 1 byte input into the stack (0c), which is where the main aim of the level is, to make sure our `EQ` returns true.

Last hint: 0100 is in hex :)

### Level 6

We're introduced to the `CALLDATALOAD` opcode in this level and what this opcode does is to pop a value from the stack and use the value as the `offset` to read from our calldata, note that 1 byte has been pushed on to the stack with the help of the `PUSH!` opcode, and pushing 00 to the stack means that the  `CALLDATALOAD` opcode is going to read the value at the "0 bytes" offset, so to solve the levele we have to pass in a calldata that has the valid PC (0A) jumpdest insrtuction at the index value of 0


### Level 7

This level is a bit more complex as we are introduced to a few more opcodes, below is a brief info on the new opcodes  
- `CALLDATACOPY` takes in 3 values as inputs and then copies the calldata value from the tx data to the memory, NB the first input is `destOffset` and thois just indicates the byte offset in memory where the copy operation's result will be copied to.
The second input is the `offset` and this just represents the byte offset in the calldata from which we want to start to copy from
Lastly we have the 3rd input `size` which just indicates the byte size of the data from calldata we intend to copy in memory
- `CREATE` this opcode deploys a new contract. It also pops 3 values from the stack to use as input of the deployment operation. The result of the `CREATE` operation is an address of the deployed contract that's been pushed to the stack.
First input: `value` this is just the value in wei to send to the new account
Second input `offset` the byte offset from where we want to start copy the new contract's code from the memory
Third input: `size` the byte size of instruction to copy starting from the memory offset
- `EXTCODESIZE` pops a value from the stack to be used as a 20-byte address. This address will then be used to "query" the destination contract and the result returned is the byte size of the contract's code. The result is then pushed back to the stack.

So in order to solve this level we neeed to pass in a calldata whose extcodesize returns 1 when checked on the deployed code, remember that when the `CREATE` opcode gets executed the runtime code is only the code that gets returned, the other part of the code is just the constructor logic, so all we have to do is make sure that we return 1 byte from the `CREATE` operation.
Last hint remember that the `RETURN` opcode pops 2 values from the stack, where the first one is the memory offset from where to start to read and the second one is memory size in bytes to read and return.
Our goal is to execute RETURN(0,1), where 0 is the offset and 1 is size, don't forget LIFO.




lvl.1 - 8
lvl.2 - 4
lvl.3 - 0x98989898
lvl.4 - 6
lvl.5 - 16
lvl.6 - 0x000000000000000000000000000000000000000000000000000000000000000A
lvl.7 -  0x600160015360016000f3



