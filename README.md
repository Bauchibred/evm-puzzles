# EVM-PUZZLES

EVM Puzzles is created by Franco Victorio... [see link](https://github.com/fvictorio/evm-puzzles), each puzzle includes sending a successful transaction to a contract. The bytecode of the contract is always provided, and we just need to fill the transaction data that won't revert the execution, below I'm just going to try as much as possible to give subtle hints on how to solve each level.

# How to play 
```
git clone https://github.com/fvictorio/evm-puzzles.git
cd evm-puzzles
npm install
npx hardhat play
```

### Level 1

Here we just need make the contract jump to the PC (program counter) 08 that is marked by the JUMPDEST opcode.
You might think, from where do we get the `value` to use for `JUMP`, well remember the EVM stack works as a LIFO (Last In, First Out) queue so that means that the `JUMP` takes in the first value from the stack and uses as the parameter to where it needs to jump to.
And for this level the `value` is added to the stack from the `CALLVALUE` opcode, since this is the forst opcode that's been executed, remember that the `CALLVALUE` opcode pushes the value of our current call in `wei`, so in essence we need to pass in the correct value to the contract in order to make the `CALLVALUE` opcode to push the correct byte offset to make it jump to the valid JUMPDEST at PC 8.

### Level 2

The case here is similar to that of the previous level since we just need to have the correct value in the EVM Stack when the JUMP opcode is executed. You should know we need the value 6 in order to land in a valid JUMPDEST opcode.

Asides `CALLVALUE` which we know to push the `msg.value` to the stack, here we also have `CODESIZE`, what this opcode does is just push the contract's code size in bytes to the stack, and then the `SUB` opcode just as the name it pops 2 values from the stack, substracts them and then push the result back to the stack

NB: After `SUB` the stack would have the value CODESIZE - CALLVALUE. 


### Level 3

This level is still a look alike of the previous two, we just need to have the value `4` in the stack when we jump in order to land in a valid `JUMPDEST` opcode, the only opcode present in this level is the `CALLDATASIZE` which just pushes the byte size of the calldata to the stack.

Below is OZ's explanation of what a calldata is, this should help you understand what to pass in
"the calldata is an encoded chunk of hexadecimal numbers that contains information about what function of the contract we want to call, and it’s arguments or data. Simply put, it consists of a “function id”, which is generated by hashing the function’s signature (truncated to the first leading four bytes) followed by the packed arguments data."



### Level 4

Similar to previous levels we need to pass the correct value to the `CALLVALUE` opcode to make the jump valid that means that it has to be at where the JUMPDEST opcode exists at the PC 10 (0A in hex).

Here we have the `CALLVALUE` and `CODESIZE` opcodes, from previous levels we know what they both do, but in addition for this level we have `XOR` opcode, what this does is pop the top 2 valuse in the stack and then performs the bitwise XOR operation between them and the result is pushed back on stack, don't forget LIFO. In short we need to pass in a `msg.value` after which with the XOR operation must equal 10, note that that our `CODESIZE` is 12.


### Level 5

Here the `JUMPI` opcode is introduced and this opcode can be used to implement functionalities like loops and conditions.

NB: when the `JUMPI` opcode is executed it pops 2 values from the stack, the first being the PC value with the valid JUMPDEST instruction, and the second value is a bool flag (0 or 1) where if 1 we jump if otherwise we don't jump.

So to solve this level all we need to pass is a value whose square is equal to 0100 (the 2 bytes value that's been passed in the stack by the `PUSH2` opcode) you might think why square? well after passing in the value using the `CALLVALUE` opcode, the `DUP1` opcode gets executed and this opocode just duplicates the first value in the stack and push it on top of the stack, then the `MUL` opcode is executed which just multiplies the top two values in the stack, then the `PUSH2` is called that passes the 0100 and then the `EQ` opcode which just pops 2 values from the stack, and returns 1 to the stack if the 2 values are equal otherwise 0, since the last opcode before the `JUMP` is to `PUSH` a 1 byte input into the stack (0c), which is where the main aim of the level is, to make sure our `EQ` returns true.

Last hint: 0100 is in hex :)

### Level 6

We're introduced to the `CALLDATALOAD` opcode in this level and what this opcode does is to pop a value from the stack and use the value as the `offset` to read from our calldata, note that 1 byte has been pushed on to the stack with the help of the `PUSH!` opcode, and pushing 00 to the stack means that the  `CALLDATALOAD` opcode is going to read the value at the "0 bytes" offset, so to solve the levele we have to pass in a calldata that has the valid PC (0A) jumpdest insrtuction at the index value of 0


### Level 7

