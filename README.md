# EVM-PUZZLES

EVM Puzzles is created by Franco Victorio... [see link](https://github.com/fvictorio/evm-puzzles), each puzzle includes sending a successful transaction to a contract. The bytecode of the contract is always provided, and we just need to fill the transaction data that won't revert the execution, below I'm just going to try as much as possible to give subtle hints on how to solve each level.

## How to play 
```
git clone https://github.com/fvictorio/evm-puzzles.git
cd evm-puzzles
npm install
npx hardhat play
```

### Level 1

Here we just need make the contract jump to the PC (program counter) 08 that is marked by the JUMPDEST opcode.
You might think, from where do we get the `value` to use for `JUMP`, well remember the EVM stack works as a LIFO (Last In, First Out) queue so that means that the `JUMP` takes in the first value from the stack and uses as the parameter to where it needs to jump to.
And for this level the `value` is added to the stack from the `CALLVALUE` opcode, since this is the forst opcode that's been executed, remember that the `CALLVALUE` opcode pushes the value of our current call in `wei`, so in essence we need to pass in the correct value to the contract in order to make the `CALLVALUE` opcode to push the correct byte offset to make it jump to the valid JUMPDEST at PC 8.

### Level 2

The case here is similar to that of the previous level since we just need to have the correct value in the EVM Stack when the JUMP opcode is executed. You should know we need the value 6 in order to land in a valid JUMPDEST opcode.

Asides `CALLVALUE` which we know to push the `msg.value` to the stack, here we also have `CODESIZE`, what this opcode does is just push the contract's code size in bytes to the stack, and then the `SUB` opcode just as the name it pops 2 values from the stack, substracts them and then push the result back to the stack

NB: After `SUB` the stack would have the value CODESIZE - CALLVALUE. 

### Level 3

This level is still a look alike of the previous two, we just need to have the value `4` in the stack when we jump in order to land in a valid `JUMPDEST` opcode, the only opcode present in this level is the `CALLDATASIZE` which just pushes the byte size of the calldata to the stack.

Below is OZ's explanation of what a calldata is, this should help you understand what to pass in
"the calldata is an encoded chunk of hexadecimal numbers that contains information about what function of the contract we want to call, and it’s arguments or data. Simply put, it consists of a “function id”, which is generated by hashing the function’s signature (truncated to the first leading four bytes) followed by the packed arguments data."

### Level 4

Similar to previous levels we need to pass the correct value to the `CALLVALUE` opcode to make the jump valid that means that it has to be at where the JUMPDEST opcode exists at the PC 10 (0A in hex).

Here we have the `CALLVALUE` and `CODESIZE` opcodes, from previous levels we know what they both do, but in addition for this level we have `XOR` opcode, what this does is pop the top 2 valuse in the stack and then performs the bitwise XOR operation between them and the result is pushed back on stack, don't forget LIFO. In short we need to pass in a `msg.value` after which with the XOR operation must equal 10, note that that our `CODESIZE` is 12.

### Level 5

Here the `JUMPI` opcode is introduced and this opcode can be used to implement functionalities like loops and conditions.

NB: when the `JUMPI` opcode is executed it pops 2 values from the stack, the first being the PC value with the valid JUMPDEST instruction, and the second value is a bool flag (0 or 1) where if 1 we jump if otherwise we don't jump.

So to solve this level all we need to pass is a value whose square is equal to 0100 (the 2 bytes value that's been passed in the stack by the `PUSH2` opcode) you might think why square? well after passing in the value using the `CALLVALUE` opcode, the `DUP1` opcode gets executed and this opocode just duplicates the first value in the stack and push it on top of the stack, then the `MUL` opcode is executed which just multiplies the top two values in the stack, then the `PUSH2` is called that passes the 0100 and then the `EQ` opcode which just pops 2 values from the stack, and returns 1 to the stack if the 2 values are equal otherwise 0, since the last opcode before the `JUMP` is to `PUSH` a 1 byte input into the stack (0c), which is where the main aim of the level is, to make sure our `EQ` returns true.

Last hint: 0100 is in hex :)

### Level 6

We're introduced to the `CALLDATALOAD` opcode in this level and what this opcode does is to pop a value from the stack and use the value as the `offset` to read from our calldata, note that 1 byte has been pushed on to the stack with the help of the `PUSH!` opcode, and pushing 00 to the stack means that the  `CALLDATALOAD` opcode is going to read the value at the "0 bytes" offset, so to solve the levele we have to pass in a calldata that has the valid PC (0A) jumpdest insrtuction at the index value of 0

### Level 7

This level is a bit more complex as we are introduced to a few more opcodes, below is a brief info on the new opcodes  
- `CALLDATACOPY` takes in 3 values as inputs and then copies the calldata value from the tx data to the memory, NB the first input is `destOffset` and thois just indicates the byte offset in memory where the copy operation's result will be copied to.
The second input is the `offset` and this just represents the byte offset in the calldata from which we want to start to copy from
Lastly we have the 3rd input `size` which just indicates the byte size of the data from calldata we intend to copy in memory
- `CREATE` this opcode deploys a new contract. It also pops 3 values from the stack to use as input of the deployment operation. The result of the `CREATE` operation is an address of the deployed contract that's been pushed to the stack.
First input: `value` this is just the value in wei to send to the new account
Second input `offset` the byte offset from where we want to start copy the new contract's code from the memory
Third input: `size` the byte size of instruction to copy starting from the memory offset
- `EXTCODESIZE` pops a value from the stack to be used as a 20-byte address. This address will then be used to "query" the destination contract and the result returned is the byte size of the contract's code. The result is then pushed back to the stack.

So in order to solve this level we neeed to pass in a calldata whose extcodesize returns 1 when checked on the deployed code, remember that when the `CREATE` opcode gets executed the runtime code is only the code that gets returned, the other part of the code is just the constructor logic, so all we have to do is make sure that we return 1 byte from the `CREATE` operation.
Last hint remember that the `RETURN` opcode pops 2 values from the stack, where the first one is the memory offset from where to start to read and the second one is memory size in bytes to read and return.
Our goal is to execute RETURN(0,1), where 0 is the offset and 1 is size, don't forget LIFO.

### Level 8

This level is similar to the previous, the only new opcodes here: `SWAP5` this opcode swaps the opcode in the zeroth position with the one in 5th.
`GAS` pushes the remaining gas in the transaction after an operation onto the stack 
`CALL` opcode pushes to the stack the 0 if the call reverted, otherwise 1. After the execution, it keeps the normal flow. NB: call returns success as true even if the account called have no code. Also note that this opcode pops 7 elements from the stack to be used as parameters when executing it: 
gas, address, value:, argsSize, retOffset, retSize.

Main hint to solve this level is to divide the PCs to different blocks and remember that the main thing is to pass in a call that reverts, cause since at position 14 we have thew `EQ` opcode that's after pushing 00 onto the stack so that means our call has to return 0 in order for us to be able to jump to 1B, cause otherwise the we'd go with the normal flow and end up executing the `REVERT` opcode in position `1A`.
Last hint: Having a calldata which only includes the `REVERT` opcode as the code of the contract works too, and don't forget to return the stored code.

### Level 9

Two new opcodes are introduced in this level:
`LT` pops 2 values from the stack and push the result of "value0 < value1" to the stack, If the result is true, it pushes 1 otherwise 0.
`CALLVALUE` pushes to the stack the value of the current call in wei

So, first hint is to make sure the size of the calldata is > 3 bytes so to make the stack not follow the `JUMPI` jump and revert, we then see that the value in wei and the size of our calldata is being pushed on to the stack to be multiplied with the help of the `CALLVALUE` `CALLDATASIZE` opcodes and what's being returned after this execution has to be equal to 8 in order for the stack to jump to the valid jumpdest instruction.

### Level 10
Three new opcodes are introduced in this level:
`GT` pops 2 values from the stack and pushes the result of value0 > value1 to the stack. If the result is true, it pushes 1 otherwise 0
MOD: pops 2 values from the stack and pushs back to the stack the result of `value0 % value1`. NB: If the denominator  is 0 the result will be 0
`ISZERO` pops a value from the stack and checks if the value is zero or not.

First hint to solve this level is to pass in a value that's less than or equal to 27 so we follow the `JUMPI` instruction and not revert (why 27? you might think, we have just 24 instructions, but remember that some instructions include the `PUSHX` opcode, in this case we have, which equates our codesize to 27)
The next instructions are CALLDATASIZE, push 0x0003, swap them, then perform a MOD(0x0003, CALLDATASIZE), the `ISZERO` opcode is then checked on the first value present in the stack. Since we just performed the MOD operation, we have ISZERO(MOD(0x0003, CALLDATASIZE)), what's returned from this is going to be used by the `JUMPI` opcode to know if to jump or not and revert, so meaning that size of our `calldata` must be divisible by 3 to make 3 % CALLDATASIZE equal to 0.
The value is then added to `0A` and used as the position that we will perform the jump to, this means that the only value we can use is 15 or in hex `0F` cause our valid jumpdest instructon is at position 19 `25 in decimal`


## Solutions

#### 1 - 8
#### 2 - 4
#### 3 - 0x98989898
#### 4 - 6
#### 5 - 16
#### 6 - 0x000000000000000000000000000000000000000000000000000000000000000A
#### 7 -  0x600160015360016000f3
#### 8 - 0x60FD60005360016000F3
#### 9 - 2, 0x12345678
#### 10 - 15, 0x123456
